import os
from collections.abc import Callable
from contextlib import suppress
from hashlib import sha1
from io import BytesIO

from flask import Flask, jsonify
from flask_httpauth import HTTPTokenAuth
from gds_metrics import GDSMetrics
from notifications_utils import request_helper
from notifications_utils.celery import NotifyCelery
from notifications_utils.clients.otel.otel_client import OtelClient
from notifications_utils.clients.signing.signing_client import Signing
from notifications_utils.clients.statsd.statsd_client import StatsdClient
from notifications_utils.logging import flask as utils_logging
from notifications_utils.s3 import S3ObjectNotFound, s3download, s3upload

from app import weasyprint_hack

notify_celery = NotifyCelery()
metrics = GDSMetrics()


def create_app():
    application = Flask(__name__)

    from app.config import Config, configs

    notify_environment = os.environ["NOTIFY_ENVIRONMENT"]
    if notify_environment in configs:
        application.config.from_object(configs[notify_environment])
    else:
        application.config.from_object(Config)

    init_app(application)

    # Metrics intentionally high up to give the most accurate timing and reliability that the metric is recorded
    metrics.init_app(application)

    from app.precompiled import precompiled_blueprint
    from app.preview import preview_blueprint
    from app.status import status_blueprint

    application.register_blueprint(status_blueprint)
    application.register_blueprint(preview_blueprint)
    application.register_blueprint(precompiled_blueprint)

    application.statsd_client = StatsdClient()
    application.otel_client = OtelClient()
    application.statsd_client.init_app(application)
    application.signing_client = Signing()
    application.signing_client.init_app(application)
    utils_logging.init_app(application, application.statsd_client, application.otel_client)
    weasyprint_hack.init_app(application)
    request_helper.init_app(application)
    notify_celery.init_app(application)

    application.cache = init_cache(application)

    @auth.verify_token
    def verify_token(token):
        return token in application.config["TEMPLATE_PREVIEW_INTERNAL_SECRETS"]

    return application


auth = HTTPTokenAuth(scheme="Token")


def init_cache(application):
    def cache(*args, folder=None, extension="file"):
        cache_key = "{}/{}.{}".format(
            folder,
            sha1("".join(str(arg) for arg in args).encode("utf-8")).hexdigest(),
            extension,
        )

        def wrapper(original_function) -> Callable[[], BytesIO]:
            def new_function() -> BytesIO:
                with suppress(S3ObjectNotFound):
                    return BytesIO(
                        s3download(
                            application.config["LETTER_CACHE_BUCKET_NAME"],
                            cache_key,
                        ).read()
                    )

                data = original_function()

                s3upload(
                    data,
                    application.config["AWS_REGION"],
                    application.config["LETTER_CACHE_BUCKET_NAME"],
                    cache_key,
                )

                data.seek(0)
                return BytesIO(data.read())

            return new_function

        return wrapper

    return cache


def init_app(app):
    @app.errorhandler(InvalidRequest)
    def invalid_request(error):
        app.logger.warning(error.message)
        return jsonify(result="error", message=error.message or ""), error.code

    @app.errorhandler(Exception)
    def exception(error):
        app.logger.exception(error)

        if hasattr(error, "message"):
            # error.code is set for our exception types.
            return (
                jsonify(result="error", message=error.message or ""),
                error.code or 500,
            )
        elif hasattr(error, "code"):
            # error.code is set for our exception types.
            return jsonify(result="error"), error.code or 500
        else:
            # error.code is set for our exception types.
            return jsonify(result="error", message=str(error)), 500

    @app.errorhandler(400)
    def bad_request(error):
        # All requests to this app are internal and all 400 responses
        # should be generated by raising InvalidRequest. Any other 400
        # responses indicate a bug in our internal requests.
        app.logger.error(str(error))
        return jsonify(result="error", message=str(error)), 400

    @app.errorhandler(404)
    def page_not_found(e):
        msg = e.description or "Not found"
        return jsonify(result="error", message=msg), 404


class InvalidRequest(Exception):
    def __init__(self, message, code=400):
        self.message = message
        self.code = code


class ValidationFailed(Exception):
    def __init__(self, message, invalid_pages=None, page_count=None, code=400):
        self.message = message
        self.invalid_pages = invalid_pages
        self.code = code
        self.page_count = page_count
